#pragma kernel density

#include "simplex.compute"

////////// BUFFER AND VARIABLE //////////

RWStructuredBuffer<float4> points;
int numPointAxis;

float3 playerSpawn;
float3 endZone;

//world position of the chunk 
float3 chunkPos;

//coord of the chunk
float3 chunkCoord;

//noise setting
float lacunarity;
float persistence;
int octave;
float seed;

//area setting
float spawnSize;
float bossSize;
float tunnelSize;

////////// HELP FUNCTION //////////

uint indexFromCoord(int3 id) {
    return id.z * numPointAxis * numPointAxis + id.y * numPointAxis + id.x;
}

////////// MAIN FUNCTION NOISE //////////

[numthreads(8,8,8)]
void density (int3 id : SV_DispatchThreadID)
{

    if(id.x >= numPointAxis || id.y >= numPointAxis || id.z >= numPointAxis)
    {
        return;
    }

    float3 pos = chunkCoord + (float3(id)/float(numPointAxis-1));

	pos *= (numPointAxis/64.);

	//get the pos
	uint index = indexFromCoord(id);  

	float densityValue = 0.;

	for(int i = 0; i < octave; i++)
	{
		float l = pow(abs(lacunarity), float(i));
		float p = pow(abs(persistence), float(i));
		densityValue += snoise((float3(seed,seed,seed) + pos) * l) * p ;
	}

	densityValue += (densityValue + 1.) / 2.;

	points[index] = float4(id, densityValue);
	pos = chunkPos + id;

	///////   special gen area (spawn, tunnel, hardfloor and boss area)    ////////

	if(pos.y < -100)
	{
		points[index] = float4(id, 1.);
		return;
	}

	float sphereStart = distance(playerSpawn, pos);

	if (sphereStart < spawnSize)
	{
		points[index] = float4(id, sphereStart - spawnSize);
		return;
	}

	float sphereEnd = distance(endZone, pos);
	if (sphereEnd < bossSize)
	{
		points[index] = float4(id, sphereEnd - bossSize);
		return;
	}

	float tube1 = distance(pos, float3(sin(pos.z / 10.) * 6., cos(pos.z / 10.) * 6. - pos.z / 6., pos.z));
    float tube2 = distance(pos, float3(cos(pos.z / 10.) * 6., sin(pos.z / 10.) * 6. - pos.z / 6., pos.z));

	if (tube1 < tunnelSize && densityValue > tube1 - tunnelSize) 
	{
    points[index] = float4(id, tube1 - tunnelSize);
		return;
	}
	if (tube2 < tunnelSize && densityValue > tube2 - tunnelSize)
	{
		points[index] = float4(id, tube2 - tunnelSize);
		return;
	}

	
}
